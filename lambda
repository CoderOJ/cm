#ifndef CM_LAMBDA_H
#define CM_LAMBDA_H
#include <type_traits>
namespace cm::lambda{namespace _7{template<int k>struct _8{template<class Ta,class...Tb>static auto call(Ta,Tb...b){return _8<k-1>::call(b...);}};template<>struct _8<0>{template<class Ta,class...Tb>static auto call(Ta a,Tb...){return a;}};struct lambda_base{};template<class T>struct lambda_constant:public lambda_base{const T&a;lambda_constant(const T&a):a(a){}template<class...>const T&operator()(...)const{return a;}};template<class T>struct lambda_reference:public lambda_base{T&a;lambda_reference(T&a):a(a){}template<class...>T&operator()(...)const{return a;}};
#define _a(op, op_name) template <class Ta, class Tb> struct lambda_bop_##op_name : public lambda_base { static_assert(std::is_base_of<lambda_base, Ta>::value, ""); static_assert(std::is_base_of<lambda_base, Tb>::value, ""); const Ta &a; const Tb &b; lambda_bop_##op_name(const Ta &a, const Tb &b) : a(a), b(b) {} template <class... T> auto operator()(T... p) const -> decltype(a(p...) op b(p...)) { return a(p...) op b(p...); } }; template <class Ta, class Tb, typename = typename std::enable_if< std::is_base_of<lambda_base, Ta>::value || std::is_base_of<lambda_base, Tb>::value>::type> auto operator op(const Ta &a, const Tb &b) { if constexpr (!std::is_base_of<lambda_base, Ta>::value) return lambda_bop_##op_name<lambda_constant<Ta>, Tb>( lambda_constant<Ta>(a), b); else if constexpr (!std::is_base_of<lambda_base, Tb>::value) return lambda_bop_##op_name<Ta, lambda_constant<Tb>>( a, lambda_constant<Tb>(b)); else return lambda_bop_##op_name<Ta, Tb>(a, b); } template <class Ta, class Tb, typename = typename std::enable_if< !std::is_base_of<lambda_base, Ta>::value && std::is_base_of<lambda_base, Tb>::value>::type> auto operator op(Ta &a, const Tb &b) { return lambda_bop_##op_name<lambda_reference<Ta>, Tb>( lambda_reference<Ta>(a), b); } template <class Ta, class Tb, typename = typename std::enable_if< std::is_base_of<lambda_base, Ta>::value && !std::is_base_of<lambda_base, Tb>::value>::type> auto operator op(const Ta &a, Tb &b) { return lambda_bop_##op_name<Ta, lambda_reference<Tb>>( a, lambda_reference<Tb>(b)); }
_a(+,add);_a(-,sub);_a(*,mul);_a(/,div);_a(<,le);_a(<=,leq);_a(>,ge);_a(>=,geq);_a(==,eq);_a(!=,neq);_a(<<,lsh);_a(>>,rsh);_a(&&,and);_a(||,or);_a(&,land);_a(|,lor);_a(^,lxor);
#define _9(op, op_name) template <class Ta> struct lambda_sop_##op_name : public lambda_base { static_assert(std::is_base_of<lambda_base, Ta>::value, ""); const Ta &a; lambda_sop_##op_name(const Ta &a) : a(a) {} template <class... T> auto operator()(T... p) const -> decltype(op a(p...)) { return op a(p...); } }; template <class Ta, typename = typename std::enable_if< std::is_base_of<lambda_base, Ta>::value>::type> auto operator op(const Ta &a) { return lambda_sop_##op_name<Ta>(a); }
_9(!,not);_9(~,lnot);_9(+,pos);_9(-,neg);}namespace placehoders{template<int k>struct placeholder:public _7::lambda_base{template<class...T>auto operator()(T...p)const{return _7::_8<k>::call(p...);}};placeholder<0>_1;placeholder<1>_2;placeholder<2>_3;placeholder<3>_4;placeholder<4>_5;placeholder<5>_6;}}
#endif
