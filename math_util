#ifndef CM_MATH_BASE_H
#define CM_MATH_BASE_H
#include <vector>
namespace cm{template<class _8>struct math_util{static class _1{private:std::vector<_8>_5;public:void require(int n){n++;int c=static_cast<int>(_5.size());if(c<n){_5.resize(n);if(c==0){_5[0]=1;c=1;}for(int i=c;i<n;i++){_5[i]=_5[i-1]*_8(i);}}}_8 operator()(int i)const{return _5[i];}_8 get(int i){require(i);return _5[i];}}fac;static class _2{private:std::vector<_8>_7;static constexpr int MOD=_8::MOD;public:void require(int n){n++;int c=static_cast<int>(_7.size());if(c<n){_7.resize(n);if(c==0){_7[0]=1;c=1;}if(c==1&&n>1){_7[1]=1;c=2;}for(int i=c;i<n;i++){_7[i]=_7[MOD%i]*(MOD-MOD/i);}}}_8 operator()(int i)const{return _7[i];}_8 get(int i){require(i);return _7[i];}}inv;static class _3{private:std::vector<_8>_6;public:void require(int n){fac.require(n);int c=static_cast<int>(_6.size());if(n>c){_6.resize(n+1);_6[n]=fac(n).inv();for(int i=n-1;i>=c;i--)_6[i]=_6[i+1]*_8(i+1);}}_8 operator()(int i)const{return _6[i];}_8 get(int i){require(i);return _6[i];}}ifac;static class _4{public:void require(int n){fac.require(n);ifac.require(n);}_8 operator()(int n,int m){if(m<0||m>n)return _8(0);return fac(n)*ifac(m)*ifac(n-m);}_8 get(int n,int m){if(m<0||m>n)return _8(0);return fac.get(n)*ifac.get(m)*ifac.get(n-m);}}binom;};template<class _8>typename math_util<_8>::_1 math_util<_8>::fac;template<class _8>typename math_util<_8>::_2 math_util<_8>::inv;template<class _8>typename math_util<_8>::_3 math_util<_8>::ifac;template<class _8>typename math_util<_8>::_4 math_util<_8>::binom;}
#endif
