#ifndef CM_DEBUG_H
#define CM_DEBUG_H
#include <iostream>
#include <iterator>
#include <string>
#include <tuple>
#include <utility>
namespace cm{
#ifdef CM_DEBUG
class logger{private:std::ostream*_f;std::string _c="\x2c\x20";int _d=0;bool _8=true;int _6=0;std::string _e(const std::string&_10){if(_10=="red")return "\033[0;31m";if(_10=="green")return "\033[0;32m";if(_10=="yellow")return "\033[0;33m";if(_10=="blue")return "\033[0;34m";if(_10=="magenta")return "\033[0;35m";if(_10=="cyan")return "\033[0;36m";if(_10=="red bold")return "\033[1;31m";if(_10=="green bold")return "\033[1;32m";if(_10=="yellow bold")return "\033[1;33m";if(_10=="blue bold")return "\033[1;34m";if(_10=="magenta bold")return "\033[1;35m";if(_10=="cyan bold")return "\033[1;36m";if(_10=="reset")return "\033[0m";return "";}public:explicit logger(std::ostream&_f):_f(&_f){}logger&set_ostream(std::ostream&_f){this->_f=&_f;return*this;}logger&set_sep(const std::string&_c){this->_c=_c;return*this;}logger&assert_push_enable(){_d-=1;if(_d)_d=0;return*this;}logger&assert_push_disable(){_d+=1;return*this;}logger&assert_exit(){_8=true;return*this;}logger&assert_noexit(){_8=false;return*this;}logger&set_exit_code(int _1){_6=_1;return*this;}logger&endl(){*_f<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_c).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_f<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_9){log("{");for(auto it=_9.begin();it!=_9.end();++it){if(it!=_9.begin())log(_c);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _a="cyan"){_a=_e(_a);return log(_a).log(x).log("\x3a\x20").log(_e("reset"));}template<class...T>logger&operator()(T..._b){return log(_b...).endl();}template<class...T>logger&assert_(const std::string&_2,int _3,const std::string&_4,bool _b,const std::string&_7,T..._5){if(_d==0&&!_b){endl().hint(_2,"magenta").hint(_3,"magenta").log(_e("yellow")).log("Assertion `").log(_e("yellow bold")).log(_4).log(_e("yellow")).log("` failed").log(_e("reset")).endl();if(_7!="")hint("detail","magenta").hint(_7)(_5...);if(_8)exit(_6);}return*this;}};
#else
class logger{public:logger(std::ostream&){}logger&set_ostream(std::ostream&){return*this;}logger&set_sep(const std::string&){return*this;}logger&assert_push_enable(){return*this;}logger&assert_push_disable(){return*this;}logger&assert_exit(){return*this;}logger&assert_noexit(){return*this;}logger&set_exit_code(int){return*this;}logger&endl(){return*this;}template<class...T>logger&log(T...){return*this;}template<class T>logger&hint(T...){return*this;}template<class...T>logger&operator()(T...){return*this;}template<class...T>logger&assert_(T...){return*this;}};
#endif
namespace impl{logger cm_logger(std::cout);}}
#ifdef CM_DEBUG
#define see(arg...) cm::impl::cm_logger.hint(#arg)(arg)
#define asee(arg...) cm::impl::cm_logger.hint(__FILE__, "magenta").hint(__LINE__, "magenta").hint(#arg)(arg)
#define cm_assert(val, arg...) cm::impl::cm_logger.assert_(__FILE__, __LINE__, #val, val, #arg, ##arg)
#else
#define see(...)
#define asee(...)
#define cm_assert(...)
#endif
#endif
