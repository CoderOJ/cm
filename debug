#ifndef CM_DEBUG_H
#define CM_DEBUG_H 1
#include <iostream>
#include <utility>
#include <tuple>
#include <iterator>
#include <string>
namespace cm{class logger{private:std::ostream*_1a;std::string _19="\x2c\x20";bool _13=true;std::string _1="\033[0;31m";std::string _2="\033[0;32m";std::string _14="\033[0;33m";std::string _3="\033[0;34m";std::string _4="\033[0;35m";std::string _5="\033[0;36m";std::string _6="\033[1;31m";std::string _7="\033[1;32m";std::string _11="\033[1;33m";std::string _8="\033[1;34m";std::string _9="\033[1;35m";std::string _a="\033[1;36m";std::string _15="\033[0m";std::string _b(std::string _1b){if(_1b=="red")return _1;if(_1b=="green")return _2;if(_1b=="yellow")return _14;if(_1b=="blue")return _3;if(_1b=="magenta")return _4;if(_1b=="cyan")return _5;if(_1b=="red bold")return _6;if(_1b=="green bold")return _7;if(_1b=="yellow bold")return _11;if(_1b=="blue bold")return _8;if(_1b=="magenta bold")return _9;if(_1b=="cyan bold")return _a;if(_1b=="reset")return _15;return "";}public:logger(std::ostream&_1a):_1a(&_1a){}logger&set_ostream(std::ostream&_1a){this->_1a=&_1a;return*this;}logger&set_sep(const std::string&_19){this->_19=_19;return*this;}logger&assert_exit(){_13=true;return*this;}logger&assert_noexit(){_13=false;return*this;}logger&endl(){*_1a<<std::endl;return*this;}logger&log(){return*this;}template<class Ta,class Tb,class...Tc>logger&log(const Ta&a,const Tb&b,Tc...c){return log(a).log(_19).log(b,c...);}template<class Ta,typename=decltype(std::cout<<std::declval<Ta>())>logger&log(const Ta&a){*_1a<<a;return*this;}template<class T,typename=decltype(std::declval<T>().begin()),typename=decltype(std::declval<T>().end()),typename=typename std::enable_if<!std::is_base_of<std::string,typename std::decay<T>::type>::value>::type,typename value_type=typename T::value_type>logger&log(const T&_16){log("{");for(auto it=_16.begin();it!=_16.end();++it){if(it!=_16.begin())log(_19);log(*it);}log("}");return*this;}template<class Ta,class Tb>logger&log(const std::pair<Ta,Tb>&x){return log("(").log(x.first,x.second).log(")");}
#if __cplusplus >= 201703L
template<class...T>logger&log(const std::tuple<T...>&x){log("(");std::apply([this](auto...x){this->log(x...);},x);return log(")");}
#else
template<class...T>logger&log(const std::tuple<T...>&){return log("<tuple>");}
#endif
template<class T>logger&hint(const T&x,std::string _17="cyan"){_17=_b(_17);return log(_17).log(x).log("\x3a\x20").log(_15);}template<class...T>logger&operator()(T..._18){return log(_18...).endl();}template<class...T>logger&_c(const std::string&_d,int _e,const std::string&_f,bool _18,const std::string&_12,T..._10){if(!_18){endl();hint(_d,"magenta").hint(_e,"magenta").log(_14).log("Assertion `").log(_11).log(_f).log(_14).log("` failed").log(_15).endl();if(_12!="")hint("detail","magenta").hint(_12)(_10...);if(_13)exit(0);}return*this;}};namespace impl{logger see_logger(std::cout);}}
#ifdef CM_DEBUG
#define see(arg...) cm::impl::see_logger.hint(#arg)(arg)
#define asee(arg...) cm::impl::see_logger.hint(__FILE__, "magenta").hint(__LINE__, "magenta").hint(#arg)(arg)
#define cm_assert(val, arg...) cm::impl::see_logger._c(__FILE__, __LINE__, #val, val, #arg, ##arg)
#else
#define see(...)
#define asee(...)
#define cm_assert(...)
#endif
#endif
